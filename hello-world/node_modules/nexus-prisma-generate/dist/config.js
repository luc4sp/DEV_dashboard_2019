"use strict";
exports.__esModule = true;
var Ajv = require("ajv");
var fs = require("fs");
var yaml = require("js-yaml");
var path = require("path");
var prisma_datamodel_1 = require("prisma-datamodel");
var schema = require('prisma-json-schema/dist/schema.json');
var ajv = new Ajv().addMetaSchema(require('ajv/lib/refs/json-schema-draft-06.json'));
var validate = ajv.compile(schema);
function findDatamodelAndComputeSchema(configPath, config) {
    var typeDefs = getTypesString(config.datamodel, path.dirname(configPath));
    var databaseType = getDatabaseType(config);
    var ParserInstance = prisma_datamodel_1.DefaultParser.create(databaseType);
    return {
        datamodel: ParserInstance.parseFromSchemaString(typeDefs),
        databaseType: databaseType
    };
}
exports.findDatamodelAndComputeSchema = findDatamodelAndComputeSchema;
function readPrismaYml(prismaYamlPath) {
    var configPath = findPrismaConfigFile(prismaYamlPath);
    if (!configPath) {
        throw new Error('Could not find `prisma.yml` file');
    }
    try {
        var file = fs.readFileSync(configPath, 'utf-8');
        var config = yaml.safeLoad(file);
        var valid = validate(config);
        if (!valid) {
            var errorMessage = "Invalid prisma.yml file" + '\n' + ajv.errorsText(validate.errors);
            throw new Error(errorMessage);
        }
        if (!config.datamodel) {
            throw new Error('Invalid prisma.yml file: Missing `datamodel` property');
        }
        if (!config.generate) {
            throw new Error('Invalid prisma.yml file: Missing `generate` property for a `prisma-client`');
        }
        return { config: config, configPath: configPath };
    }
    catch (e) {
        throw new Error("Yaml parsing error in " + configPath + ": " + e.message);
    }
}
exports.readPrismaYml = readPrismaYml;
function findPrismaConfigFile(prismaYmlPath) {
    if (prismaYmlPath && !fs.existsSync(prismaYmlPath)) {
        return null;
    }
    var definitionPath = path.join(process.cwd(), 'prisma.yml');
    if (fs.existsSync(definitionPath)) {
        return definitionPath;
    }
    definitionPath = path.join(process.cwd(), 'prisma', 'prisma.yml');
    if (fs.existsSync(definitionPath)) {
        return definitionPath;
    }
    return null;
}
function getPrismaClientDir(prismaClientDir, prisma, rootPath) {
    if (prismaClientDir) {
        return prismaClientDir.startsWith('/')
            ? prismaClientDir
            : path.resolve(rootPath, prismaClientDir);
    }
    var clientGenerators = prisma.config.generate.filter(function (gen) {
        return ['typescript-client', 'javascript-client'].includes(gen.generator);
    });
    if (clientGenerators.length === 0) {
        throw new Error('No prisma-client generators were found in your prisma.yml file');
    }
    if (clientGenerators.length > 1) {
        throw new Error('Several prisma-client generators are defined in your prisma.yml file. If all are needed, use the `--client` option to point to the right one.');
    }
    return path.join(path.dirname(prisma.configPath), clientGenerators[0].output);
}
exports.getPrismaClientDir = getPrismaClientDir;
function getTypesString(datamodel, definitionDir) {
    var typesPaths = datamodel
        ? Array.isArray(datamodel)
            ? datamodel
            : [datamodel]
        : [];
    var allTypes = '';
    typesPaths.forEach(function (unresolvedTypesPath) {
        var typesPath = path.join(definitionDir, unresolvedTypesPath);
        if (fs.existsSync(typesPath)) {
            var types = fs.readFileSync(typesPath, 'utf-8');
            allTypes += types + '\n';
        }
        else {
            throw new Error("The types definition file \"" + typesPath + "\" could not be found.");
        }
    });
    return allTypes;
}
function findRootDirectory() {
    var cwd = process.cwd();
    var tsConfig = findConfigFile(cwd, 'tsconfig.json');
    if (tsConfig) {
        return path.dirname(tsConfig);
    }
    var packageJson = findConfigFile(cwd, 'package.json');
    if (packageJson) {
        return path.dirname(packageJson);
    }
    return cwd;
}
exports.findRootDirectory = findRootDirectory;
function findConfigFile(searchPath, configName) {
    if (configName === void 0) { configName = 'package.json'; }
    return forEachAncestorDirectory(searchPath, function (ancestor) {
        var fileName = path.join(ancestor, configName);
        return fs.existsSync(fileName) ? fileName : undefined;
    });
}
/** Calls `callback` on `directory` and every ancestor directory it has, returning the first defined result. */
function forEachAncestorDirectory(directory, callback) {
    while (true) {
        var result = callback(directory);
        if (result !== undefined) {
            return result;
        }
        var parentPath = path.dirname(directory);
        if (parentPath === directory) {
            return undefined;
        }
        directory = parentPath;
    }
}
function getImportPathRelativeToOutput(importPath, outputDir) {
    var relativePath = path.relative(path.dirname(outputDir), importPath);
    if (!relativePath.startsWith('.')) {
        relativePath = './' + relativePath;
    }
    // remove .ts or .js file extension
    relativePath = relativePath.replace(/\.(ts|js)$/, '');
    // remove /index
    relativePath = relativePath.replace(/\/index$/, '');
    // replace \ with /
    relativePath = relativePath.replace(/\\/g, '/');
    return relativePath;
}
exports.getImportPathRelativeToOutput = getImportPathRelativeToOutput;
function getDatabaseType(definition) {
    if (!definition.databaseType) {
        return prisma_datamodel_1.DatabaseType.postgres;
    }
    return definition.databaseType === 'document'
        ? prisma_datamodel_1.DatabaseType.mongo
        : prisma_datamodel_1.DatabaseType.postgres;
}
//# sourceMappingURL=config.js.map