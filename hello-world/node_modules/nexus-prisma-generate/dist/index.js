#!/usr/bin/env node
"use strict";
exports.__esModule = true;
var fs_1 = require("fs");
var graphql_1 = require("graphql");
var meow = require("meow");
var os_1 = require("os");
var path_1 = require("path");
var prisma_generate_schema_1 = require("prisma-generate-schema");
var config_1 = require("./config");
var graphql_2 = require("./graphql");
var header_1 = require("./header");
var cli = meow("\n    nexus-prisma-generate prisma-client-dir output\n\n    > Generate the building blocks for nexus-prisma\n\n    -----\n    \n    Inputs should be relative to the root of your project\n\n    --output  (required): Path to directory where you want to output the typings (eg: ./generated/nexus-prisma)\n    --project (optional): Path to Prisma definition file (prisma.yml)\n    --client  (optional): Path to your prisma-client directory (eg: ./generated/prisma-client/)\n    --js      (optional): Whether to generate the types for Javascript\n", {
    flags: {
        client: {
            type: 'string'
        },
        output: {
            type: 'string'
        },
        js: {
            type: 'boolean',
            "default": false
        },
        project: {
            type: 'string'
        }
    }
});
main(cli);
function main(cli) {
    var _a = cli.flags, prismaClientDir = _a.client, output = _a.output, jsMode = _a.js, prismaYmlPath = _a.project;
    if (!output) {
        console.log('ERROR: Missing argument --output');
        process.exit(1);
    }
    var rootPath = config_1.findRootDirectory();
    var resolvedPrismaYmlPath = prismaYmlPath !== undefined
        ? prismaYmlPath.startsWith('/')
            ? prismaYmlPath
            : path_1.join(rootPath, prismaYmlPath)
        : undefined;
    var prisma = config_1.readPrismaYml(resolvedPrismaYmlPath);
    var resolvedOutput = output.startsWith('/') ? output : path_1.join(rootPath, output);
    var resolvedPrismaClientDir = config_1.getPrismaClientDir(prismaClientDir, prisma, rootPath);
    try {
        // Create the output directories if needed (mkdir -p)
        fs_1.mkdirSync(resolvedOutput, { recursive: true });
    }
    catch (e) {
        if (e.code !== 'EEXIST')
            throw e;
    }
    var _b = config_1.findDatamodelAndComputeSchema(prisma.configPath, prisma.config), datamodel = _b.datamodel, databaseType = _b.databaseType;
    try {
        var schema = prisma_generate_schema_1.generateCRUDSchemaFromInternalISDL(datamodel, databaseType);
        var renderedDatamodel = renderDatamodelInfo(datamodel, schema, path_1.relative(rootPath, resolvedPrismaClientDir), jsMode ? 'module.exports =' : 'export default');
        var nexusPrismaTypesPath = path_1.join(resolvedOutput, 'nexus-prisma.ts');
        var nexusPrismaTypes = renderNexusPrismaTypes(schema, config_1.getImportPathRelativeToOutput(resolvedPrismaClientDir, nexusPrismaTypesPath));
        fs_1.writeFileSync(nexusPrismaTypesPath, nexusPrismaTypes);
        var datamodelPath = path_1.join(resolvedOutput, jsMode ? 'datamodel-info.js' : 'datamodel-info.ts');
        var indexPath = path_1.join(resolvedOutput, jsMode ? 'index.js' : 'index.ts');
        fs_1.writeFileSync(datamodelPath, renderedDatamodel);
        fs_1.writeFileSync(indexPath, withHeader(jsMode ? renderIndexJs() : renderIndexTs()));
        console.log("Types generated at " + output);
    }
    catch (e) {
        console.error(e);
    }
}
function withHeader(content) {
    return header_1.NEXUS_PRISMA_HEADER + "\n\n" + content + "\n  ";
}
function renderIndexJs() {
    return "const datamodelInfo = require('./datamodel-info')\n  \nmodule.exports = datamodelInfo\n  ";
}
function renderIndexTs() {
    return "export { default } from './datamodel-info'\n  ";
}
function renderDatamodelInfo(datamodel, schema, prismaClientDirRelativeToRoot, exportString) {
    return withHeader(exportString + " {\n  uniqueFieldsByModel: {\n" + datamodel.types
        .map(function (type) {
        return "    " + type.name + ": [" + type.fields
            .filter(function (field) { return field.isUnique; })
            .map(function (field) { return "'" + field.name + "'"; })
            .join(', ') + "]";
    })
        .join(',' + os_1.EOL) + "\n  },\n  embeddedTypes: [" + datamodel.types
        .filter(function (t) { return t.isEmbedded; })
        .map(function (t) { return "'" + t.name + "'"; })
        .join(', ') + "],\n  clientPath: '" + prismaClientDirRelativeToRoot.replace(/\\/g, '\\\\') + "',\n  schema: " + JSON.stringify(graphql_1.introspectionFromSchema(schema), null, 2) + "\n}\n  ");
}
function renderNexusPrismaTypes(schema, prismaClientPath) {
    var types = Object.values(schema.getTypeMap());
    var objectTypes = types.filter(function (t) { return graphql_1.isObjectType(t) && !t.name.startsWith('__') && t.name !== 'Node'; });
    var inputTypes = types.filter(graphql_1.isInputObjectType);
    var enumTypes = types.filter(function (t) { return graphql_1.isEnumType(t) && !t.name.startsWith('__'); });
    return header_1.NEXUS_PRISMA_HEADER + "\n\nimport { core } from 'nexus'\nimport { GraphQLResolveInfo } from 'graphql'\nimport * as prisma from '" + prismaClientPath + "'\n\ndeclare global {\n  interface NexusPrismaGen extends NexusPrismaTypes {}\n}\n\nexport interface NexusPrismaTypes {\n  objectTypes: {\n    fields: {\n" + objectTypes
        .map(function (type) { return "      " + type.name + ": " + getObjectTypeFieldsName(type); })
        .join(os_1.EOL) + "\n    }\n    fieldsDetails: {\n" + objectTypes
        .map(function (type) { return "      " + type.name + ": " + getObjectTypeFieldsDetailsName(type); })
        .join(os_1.EOL) + "\n    }\n  }\n  inputTypes: {\n    fields: {\n" + inputTypes
        .map(function (type) {
        return "      " + getInputObjectTypeName(type) + ": " + getInputObjectTypeFieldsName(type);
    })
        .join(os_1.EOL) + "\n    }\n  }\n  enumTypes: {\n" + enumTypes
        .map(function (type) { return "    " + type.name + ": " + getEnumTypeName(type) + ","; })
        .join(os_1.EOL) + "\n  }\n}\n\n" + objectTypes.map(renderObjectType).join(os_1.EOL) + "\n\n" + inputTypes.map(renderInputType).join(os_1.EOL) + "\n\n" + enumTypes.map(renderEnumType).join(os_1.EOL) + "\n  ";
}
function renderObjectType(type) {
    var fields = Object.values(type.getFields());
    var fieldsWithoutQueryNode = removeQueryNodeField(type, fields);
    return "// Types for " + type.name + "\n\n" + renderFields(type, fieldsWithoutQueryNode) + "\n\n" + renderFieldsArgs(type, fieldsWithoutQueryNode) + "\n\n" + renderTypeFieldDetails(type, fieldsWithoutQueryNode) + "\n";
}
function renderTypeFieldDetails(type, fields) {
    return "export interface " + getObjectTypeFieldsDetailsName(type) + " {\n" + fields
        .map(function (field) { return "  " + field.name + ": {\n    type: '" + graphql_2.getTypeName(field.type) + "'\n    args: " + (field.args.length > 0
        ? "Record<" + getTypeFieldArgName(type, field) + ", core.NexusArgDef<string>>"
        : '{}') + "\n    description: string\n    list: " + (graphql_2.isList(field.type) ? true : undefined) + "\n    nullable: " + !graphql_2.isRequired(field.type) + "\n    resolve: " + (graphql_1.isScalarType(graphql_2.getFinalType(field.type))
        ? undefined
        : "(\n      root: core.RootValue<\"" + type.name + "\">,\n      args: " + renderResolverArgs(field) + ",\n      context: core.GetGen<\"context\">,\n      info?: GraphQLResolveInfo\n    ) => " + renderResolverReturnType(field)) + "\n  }"; })
        .join(os_1.EOL) + "\n}\n  ";
}
function renderResolverArgs(field) {
    return "{ " + field.args
        .map(function (arg) { return "" + arg.name + (graphql_2.isRequired(arg.type) ? '' : '?') + ": " + getTSType(arg); })
        .join(', ') + " }  ";
}
function renderFields(type, fields) {
    return "type " + getObjectTypeFieldsName(type) + " =\n  | " + getExposableFieldsTypeName(type) + "\n" + fields
        .map(function (f) {
        return "  | { name: '" + f.name + "', args?: " + (f.args.length > 0
            ? getTypeFieldArgName(type, f) + "[] | false"
            : '[] | false') + ", alias?: string  } ";
    })
        .join(os_1.EOL) + "\n\ntype " + getExposableFieldsTypeName(type) + " =\n" + fields.map(function (f) { return "  | '" + f.name + "'"; }).join(os_1.EOL) + "\n";
}
function renderFieldsArgs(type, fields) {
    return fields
        .filter(function (field) { return field.args.length > 0; })
        .map(function (field) { return renderFieldArg(type, field); })
        .join(os_1.EOL) + "\n  ";
}
function renderFieldArg(type, field) {
    return "type " + getTypeFieldArgName(type, field) + " =\n" + field.args.map(function (arg) { return "  | '" + arg.name + "'"; }).join(os_1.EOL);
}
function getTSType(graphqlType) {
    var graphqlToTypescript = {
        String: 'string',
        Boolean: 'boolean',
        ID: 'string',
        Int: 'number',
        Float: 'number',
        DateTime: 'string'
    };
    var finalType = graphql_2.getFinalType(graphqlType.type);
    var returnType = '';
    if (graphql_1.isScalarType(finalType)) {
        returnType = graphqlToTypescript[graphql_2.getTypeName(finalType)];
    }
    else if (graphql_1.isInputObjectType(finalType)) {
        returnType = getInputObjectTypeName(finalType);
    }
    else {
        returnType = "prisma." + graphql_2.getTypeName(finalType);
    }
    if (graphql_2.isList(graphqlType.type)) {
        returnType += '[]';
    }
    if (!graphql_2.isRequired(graphqlType.type)) {
        returnType += ' | null';
    }
    return returnType;
}
function renderResolverReturnType(field) {
    var returnType = getTSType(field);
    return "Promise<" + returnType + "> | " + returnType;
}
function renderInputType(input) {
    var fields = Object.values(input.getFields());
    return "export interface " + getInputObjectTypeName(input) + " {\n" + fields
        .map(function (field) {
        return "  " + field.name + (graphql_2.isRequired(input) ? '' : '?') + ": " + getTSType(field);
    })
        .join(os_1.EOL) + "\n}\nexport type " + getInputObjectTypeFieldsName(input) + " =\n  | Extract<keyof " + getInputObjectTypeName(input) + ", string>\n" + fields.map(function (f) { return "  | { name: '" + f.name + "', alias?: string  } "; }).join(os_1.EOL) + "\n  ";
}
function renderEnumType(enumType) {
    return "export type " + getEnumTypeName(enumType) + " =\n" + enumType
        .getValues()
        .map(function (value) { return "  | '" + value.name + "'"; })
        .join(os_1.EOL) + "\n  ";
}
function getExposableFieldsTypeName(type) {
    return type.name + "Fields";
}
function upperFirst(s) {
    return s.replace(/^\w/, function (c) { return c.toUpperCase(); });
}
function removeQueryNodeField(type, fields) {
    if (type.name === 'Query') {
        fields = fields.filter(function (field) { return field.name !== 'node'; });
    }
    return fields;
}
function getTypeFieldArgName(type, field) {
    return "" + type.name + upperFirst(field.name) + "Args";
}
function getObjectTypeFieldsName(type) {
    return type.name + "Object";
}
function getInputObjectTypeFieldsName(type) {
    return type.name + "InputObject";
}
function getObjectTypeFieldsDetailsName(type) {
    return type.name + "FieldDetails";
}
function getInputObjectTypeName(type) {
    return "" + type.name;
}
function getEnumTypeName(enumType) {
    return enumType.name + "Values";
}
//# sourceMappingURL=index.js.map